<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拙業園</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://seucr.github.io/"/>
  <updated>2020-03-27T07:05:34.030Z</updated>
  <id>https://seucr.github.io/</id>
  
  <author>
    <name>Patrick Simone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>翻译 |【cgroups】内存资源控制器（Memory Resource Controller）</title>
    <link href="https://seucr.github.io/2020/01/02/%E7%BF%BB%E8%AF%91-%E3%80%90cgroups%E3%80%91%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88Memory-Resource-Controller%EF%BC%89/"/>
    <id>https://seucr.github.io/2020/01/02/翻译-【cgroups】内存资源控制器（Memory-Resource-Controller）/</id>
    <published>2020-01-02T07:04:46.000Z</published>
    <updated>2020-03-27T07:05:34.030Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/02/翻译-【cgroups】内存资源控制器（Memory-Resource-Controller）/slab.png"><p><strong>内存控制器的目的：</strong></p><p>内存控制器将一组进程的内存行为与系统中其他进程隔离，它可以用于：</p><ul><li>隔离一个或一组应用。吃内存的应用可以被隔离起来，并限制一定的内存使用量。</li><li>创建一个 cgroup限制其内存使用量，这可以替换boot参数mem=XXX。</li><li>虚拟化技术可以用内存控制器限制某个虚拟机实例所用的内存。</li><li>CD/DVD烧写器可以控制系统其他部分使用的内存，从而保证不会因为内存不足而烧写失败。</li><li>还有其他一些使用场景，可以研究玩玩看（学习并hack虚拟机子系统）。</li></ul><a id="more"></a><p><strong>当前状态：</strong></p><p>linux-2.6.34-mmotm(development version of 2010/April)</p><p><strong>特性：</strong></p><ul><li>统计匿名页、file cache、swap cache使用情况并加以限制；</li><li>页被关联到per-memcg的LRU上，没有全局的LRU；</li><li>可选地，统计memory+swap使用情况并加以限制；</li><li>层级形的（hierarchical）统计</li><li>支持软件限制</li><li>…</li><li>使用量阈值通知</li><li>内存压力通知</li><li>OOM-killer和OOM-notifier</li><li>根cgroup不支持限制</li></ul><p>目前正在开发内核内存支持，当前版本提供基本功能（见2.7节）。</p><p><strong>控制文件简述：</strong></p><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>tasks</td><td>添加一个线程并显示所有线程</td></tr><tr><td>cgroup.procs</td><td>显示进程列表</td></tr><tr><td>cgroup.event_control</td><td>event_fd()接口</td></tr><tr><td>memory.usage_in_bytes</td><td>当前内存使用量（见5.5节）</td></tr><tr><td>memory.memsw.usage_in_bytes</td><td>当前memory+swap使用量（见5.5节）</td></tr><tr><td>memory.limit_in_bytes</td><td>设置/显示内存使用量限制</td></tr><tr><td>memory.memsw.limit_in_bytes</td><td>设置/显示memory+swap使用量限制</td></tr><tr><td>memory.failcnt</td><td>显示内存使用量达到限制的次数</td></tr><tr><td>memory.memsw.failcnt</td><td>显示memory+swap使用量达到限制的次数</td></tr><tr><td>memory.max_usage_in_bytes</td><td>显示有记录以来的最大内存使用量</td></tr><tr><td>memory.memsw.max_usage_in_bytes</td><td>显示有记录以来的最大memory+swap使用量</td></tr><tr><td>memory.soft_limit_in_bytes</td><td>设置/显示内存使用量软限制阈值</td></tr><tr><td>memory.stat</td><td>显示统计值</td></tr><tr><td>memory.use_hierarchy</td><td>使用层级形统计（见第6章）</td></tr><tr><td>memory.force_empty</td><td>…</td></tr><tr><td>memory.pressure_level</td><td>设置内存压力通知</td></tr><tr><td>memory.swappiness</td><td>设置/显示vmscan swappiness参数</td></tr><tr><td>memory.move_charge_at_immigrate</td><td>…</td></tr><tr><td>memory.oom_control</td><td>设置/显示OOM控制</td></tr><tr><td>memory.numa_stat</td><td>显示per-NUMA节点的内存使用情况</td></tr><tr><td>memory.kmem.limit_in_bytes</td><td>设置/显示内核内存硬限制</td></tr><tr><td>memory.kmem.usage_in_bytes</td><td>显示当前内核分配内存</td></tr><tr><td>memory.kmem.failcnt</td><td>显示内核内存使用量达到限值的次数</td></tr><tr><td>memory.kmem.max_usage_in_bytes</td><td>显示有记录以来内核最大内存使用量</td></tr><tr><td>memory.kmem.tcp.limit_in_bytes</td><td>设置/显示tcp buf内存硬限制</td></tr><tr><td>memory.kmem.tcp.usage_in_bytes</td><td>显示当前tcp buf内存使用量</td></tr><tr><td>memory.kmem.tcp.failcnt</td><td>显示tcp buf内存使用量达到限值的次数</td></tr><tr><td>memory.kmem.tcp.max_usage_in_bytes</td><td>显示有记录以来最大tcp buf使用量</td></tr></tbody></table><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>内存控制器拥有漫长的历史，Balbir Singh发表过要求解释内存控制器的请求，那时候，发布了关于几种内存控制器实现的RFC，其目的是构建内存控制器最基本功能的共识。Balbir Singh在2007年2月发表了第一版RSS控制器，之后Pavel Emelianov发表了3个版本的RSS控制器，…大家都认为我们应当处理页缓存和RSS，还要允许用户空间处理OOM。当前内存控制器是版本6，它结合了映射的（RSS）和非映射的页缓存控制。</p><h1 id="内存控制器"><a href="#内存控制器" class="headerlink" title="内存控制器"></a>内存控制器</h1><p>内存是一种独特的资源，因为它的数量有限。如果一个任务需要大量的CPU处理，任务可以将其处理分散在数小时、数天、数月或数年的时间段内，但是使用内存时，需要重用相同的物理内存来完成任务。</p><p>内存控制器的实现被分成几个阶段：</p><ol><li>内存控制器</li><li>mlock控制器</li><li>内核用户内存统计和slab控制</li><li>用户映射长度控制</li></ol><p>内存控制器是第一个开发出来的控制器。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>内存控制器的核心是页计数器（page_counter），它追踪添加到控制器里的进程的当前内存使用情况以及使用限制，每个cgroup都有一个独立的内存控制器数据结构（mem_cgroup）。</p><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><img src="/2020/01/02/翻译-【cgroups】内存资源控制器（Memory-Resource-Controller）/image-20191224131451805.png"><p>上图显示了内存控制器的各个重要部分：</p><ol><li>统计是per cgroup的</li><li>每个mm_struct知道它所属的cgroup</li><li>每个页都有指向page_cgroup的指针，从而知道它所属的cgroup</li></ol><p>统计是这样达成的：</p><p>mem_cgroup_charge_common()用于初始化必要的数据结构，检查当前统计的cgroup是否超出限值。如果是，cgroup会调用页回收（reclaim，更多细节请参考文本回收章节）；如果一切OK，一个页的描述数据结构page_cgroup会被更新，page_cgroup在cgroup里有自己LRU。（page_cgroup是在boot/内存热插拔阶段分配的）</p><h3 id="统计细节"><a href="#统计细节" class="headerlink" title="统计细节"></a>统计细节</h3><p>所有映射的匿名页（RSS，Resident set size）和页缓存（Page Cache）都会被统计，一些永远都不会被回收或不会出现在LRU上的页不计入统计。我们只统计常规VM管理的页。</p><p>RSS页在page_fault时被统计，除非它们早先已经被统计过了。一个文件页（file page）在插入inode（radix-tree）时被计入Page Cache，当它被映射（mapped）进程的页表时，已经仔细处理过，不会重复统计。</p><p>一个RSS页在完全被unmapped的时候被剔除统计。当一个Page Cache的页从radix-tree中移除时，也会从统计值里 剔除。但即便RSS页已经完全unmapped（被kswapd），它已经可能存在于SwapCache里知道他们被真正释放掉。这样的SwapCaches也会被计入统计里。</p><p>一个swapped-in的页不会被计入统计，直到它被映射（mapped）。</p><p>在页迁移（page migration）阶段，统计信息依旧保留。</p><p>注意：</p><p>我们只统计LRU上的页，因为我们的目的是控制使用的页的数目；不在LRU上的页从VM的角度看不受限制。</p><h2 id="共享页的统计"><a href="#共享页的统计" class="headerlink" title="共享页的统计"></a>共享页的统计</h2><p>共享页（shared page）的统计是基于第一次访问的原则：第一次访问page的cgroup统计这个页。这个原则背后的精神是，频繁访问一个共享页的cgroup最终会统计到它（一旦拥有它的cgroup不再统计它，这在内存频繁访问时会发生）。</p><p>但请见8.2节：当一个任务移动到另一个cgroup时，它的页可能被新的cgroup重新统计，如果move_charge_at_immigrate被使能。</p><p>例外：如果CONFIG_MEMCG_SWAP没开时：</p><p>当换出（swap-off）和强制将shmem(tmpfs)页换出到后备存储器时，页的统计是由换出的调用者进行的，而非shmem的用户。</p><h2 id="页交换扩展（CONFIG-MEMCG-SWAP）"><a href="#页交换扩展（CONFIG-MEMCG-SWAP）" class="headerlink" title="页交换扩展（CONFIG_MEMCG_SWAP）"></a>页交换扩展（CONFIG_MEMCG_SWAP）</h2><p>页交换扩展使得你能记录交换的页，如果可能，换入（swap-in）的页被计入旧的页分配器里。</p><p>当交换页也被计入统计时，会新增如下文件：</p><ul><li>memory.memsw.usage_in_bytes.</li><li>memory.memsw.limit_in_bytes.</li></ul><p>其中memsw意思是memory+swap，memory+swap的使用量限值是memsw.limit_in_bytes。</p><p>例如：假设一个系统页交换阈值是4GB。在2GB内存限制下，一个任务（错误地）分配了6GB的内存会使用页交换。这是，设置memsw.limit_in_bytes=3G可以避免错误的页交换，使用这个限值，可以避免系统因为页交换引发的OOM。</p><p>× 为什么是“memory+swap”而不是swap</p><p>全局的LRU（kswapd）可以换出任意页，换出意味着将统计从memory移动到swap，但这对memory+swap来说并没有变化。换言之，当我们要限制限制页换出的使用而不影响全局LRU时，从OS角度看限制memory+swap比swap要好。</p><p>× 当cgroup达到memory.memsw.limit_in_bytes时会发生什么？</p><p>当cgroup达到memory.memsw.limit_in_bytes限值时，在cgroup的做换出没有意义。因此，cgroup不会做换出，但会清除文件缓存（file cache）。但正如上文所提，全局LRU会做内存换出，以保持系统内存管理状态的健全，cgroup不应该禁止这一点。</p><h2 id="页回收（Reclaim）"><a href="#页回收（Reclaim）" class="headerlink" title="页回收（Reclaim）"></a>页回收（Reclaim）</h2><p>每个cgroup都维护了一个per-cgroup的LRU，它与全局VM是同一个数据结构。<strong>当cgroup超过限值时，我们会先尝试将cgroup中的页回收，从而为新的页腾出空间。如果页回收失败，会调用OOM并杀掉cgroup里评分最高的任务（见第10章）。</strong></p><p>cgroup没有修改回收算法，除了要做回收的页来源于per-cgroup的LRU。</p><p>注意：回收不适用于root cgroup，因为我们不能在root cgroup上做任何限制。</p><p>注意2：当panic_on_oom=2时，整个系统会panic。</p><p>当注册有OOM事件通知时，事件会被传递（见oom_control章节）</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>（略）</p><h2 id="内核内存扩展（CONFIG-MEMCG-KMEM）"><a href="#内核内存扩展（CONFIG-MEMCG-KMEM）" class="headerlink" title="内核内存扩展（CONFIG_MEMCG_KMEM）"></a>内核内存扩展（CONFIG_MEMCG_KMEM）</h2><p>使用内核内存扩展支持，内存控制器可以用于限制系统内核内存使用量。内核内存与用户内存存在根本上的不同，因为它不会被换出，这使得通过消耗过多宝贵的内存资源让系统DoS成为可能。</p><p>（略）</p><h1 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>a. Enable CONFIG_CGROUPS<br>b. Enable CONFIG_MEMCG<br>c. Enable CONFIG_MEMCG_SWAP (用于swap extension)<br>d. Enable CONFIG_MEMCG_KMEM (用于kmem extension)</p><h2 id="准备cgroup"><a href="#准备cgroup" class="headerlink" title="准备cgroup"></a>准备cgroup</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -t tmpfs none /sys/fs/cgroup</span><br><span class="line">mkdir /sys/fs/cgroup/memory</span><br><span class="line">mount -t cgroup none /sys/fs/cgroup/memory -o memory</span><br></pre></td></tr></table></figure><h2 id="创建新的cgroup-hierarchy，将bash移入其中"><a href="#创建新的cgroup-hierarchy，将bash移入其中" class="headerlink" title="创建新的cgroup hierarchy，将bash移入其中"></a>创建新的cgroup hierarchy，将bash移入其中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/memory/0</span><br><span class="line">echo $$ &gt; /sys/fs/cgroup/memory/0/tasks</span><br></pre></td></tr></table></figure><p>因为我们目前在cgroup 0里，我们可以修改内存限值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 4M &gt; /sys/fs/cgroup/memory/0/memory.limit_in_bytes</span><br></pre></td></tr></table></figure><p>注意：我们可以用后缀（k/K/m/M/g/G）来表征值单位是千/兆/吉。</p><p>注意：我们可以用-1来表示无限制。</p><p>注意：我们不能设置root cgroup的限值。</p><p>查看限值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/fs/cgroup/memory/0/memory.limit_in_bytes</span><br><span class="line">4194304</span><br></pre></td></tr></table></figure><p>查看当前使用量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/fs/cgroup/memory/0/memory.usage_in_bytes </span><br><span class="line">385024</span><br></pre></td></tr></table></figure><p>成功写入该文件并不意味着设置成功限值为文件的内容，这可能源于一系列的原因，例如可能要round up到页对齐，或者是系统中所有可获取的内存限制。建议用户在设置这个值以后再重新读取文件，以确保内核收到了设置值。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; memory.limit_in_bytes</span><br><span class="line">cat memory.limit_in_bytes</span><br><span class="line">4096</span><br></pre></td></tr></table></figure><p>（<strong>注：</strong>我本地实验，echo 1 &gt; memory.limit_in_bytes会直接返回-EBUSY）</p><p>memory.failcnt给出了cgroup超出限值的次数。</p><p>memory.stat给出了更多统计信息，其中cache、RSS、active page、inactive page等信息都会被显示出来。</p><p><strong>注意：</strong></p><p>这份文档已经严重过时并需要完全重写，不过仍然有一些有用的信息，所以我们将它保留在这里。如果想要更深入的理解，请检查当前代码。</p><p><strong>注意：</strong></p><p>内存资源控制器（Memory Resource Controller）在这份文档里一般被称为内存控制器（memory controller），请不要与硬件的内存控制器术语混淆。</p><p><strong>在这份文档里：</strong></p><p>当我们提到cgroup内存控制器时，我们叫它“memory cgroup”。当检查git log和源代码时，patch的名字或函数名会叫做”memcg”，但在这份文档里，我们避免用这个词。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/02/翻译-【cgroups】内存资源控制器（Memory-Resource-Controller）/slab.png&quot;&gt;

&lt;p&gt;&lt;strong&gt;内存控制器的目的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;内存控制器将一组进程的内存行为与系统中其他进程隔离，它可以用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离一个或一组应用。吃内存的应用可以被隔离起来，并限制一定的内存使用量。&lt;/li&gt;
&lt;li&gt;创建一个 cgroup限制其内存使用量，这可以替换boot参数mem=XXX。&lt;/li&gt;
&lt;li&gt;虚拟化技术可以用内存控制器限制某个虚拟机实例所用的内存。&lt;/li&gt;
&lt;li&gt;CD/DVD烧写器可以控制系统其他部分使用的内存，从而保证不会因为内存不足而烧写失败。&lt;/li&gt;
&lt;li&gt;还有其他一些使用场景，可以研究玩玩看（学习并hack虚拟机子系统）。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://seucr.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>翻译 |【cgroups】进程数目控制器（Process Number Controller）</title>
    <link href="https://seucr.github.io/2020/01/02/%E7%BF%BB%E8%AF%91-%E3%80%90cgroups%E3%80%91%E8%BF%9B%E7%A8%8B%E6%95%B0%E7%9B%AE%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%88Process-Number-Controller%EF%BC%89/"/>
    <id>https://seucr.github.io/2020/01/02/翻译-【cgroups】进程数目控制器（Process-Number-Controller）/</id>
    <published>2020-01-02T06:56:04.000Z</published>
    <updated>2020-03-27T07:05:35.127Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/02/翻译-【cgroups】进程数目控制器（Process-Number-Controller）/linux.jpg"><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>cgroup hierarchy在进程数目达到上限以后会使用 进程数量控制器（process number controller）阻止继续fork或clone任何新的进程。触发进程数量限制时是否触发PID内存限制（memory cgroup）并不重要，因为PID是基础资源，因此，在cgroup hierarchy里必须要能通过限制cgourp里进程数目来阻止PID耗尽。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>设置最大进程数目到pids.max文件，就可以使用进程数量控制器（显然无法获取root cgroup的该文件）。当前cgroup中进程数量保存在pids.current文件里。</p><a id="more"></a><p>组织性的操作不会受到cgroup策略的限制，因此pids.current可能大于pids.max，这可以通过设置限制值小于pids.current，或添加足够的进程到cgroup从而pids.current &gt; pids.max。但是，通过fork()或clone()的方式违反cgroup策略，如果通过fork()或clone()创建新进程会违反cgroup策略，它们会返回-EAGAIN。</p><p>如果不要设置cgroup的进程数量限制，设置pids.max值为“max”，这也是所有新cgroups的文件默认值。（注意，PID限制也是层级性的，最终会遵循所有hierarchy里最严格的限制）</p><p>pids.current追踪所有子cgroup的层级，因此parent/pids.current是parent/child/pids.current的超集。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>首先，mount 进程控制器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount -t tmpfs cgroups /sys/fs/cgroup</span><br><span class="line">mkdir -p /sys/fs/cgroup/pids</span><br><span class="line">mount -t cgroup -o pids none /sys/fs/cgroup/pids</span><br></pre></td></tr></table></figure><p>然后，创建一个层级（hierarchy），设置限制，添加进程到里面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /sys/fs/cgroup/pids/parent/child</span><br><span class="line">echo 2 &gt; /sys/fs/cgroup/pids/parent/pids.max//创建该hierarchy的进程数量限制：2</span><br><span class="line">echo $$ &gt; /sys/fs/cgroup/pids/parent/cgroup.procs//将当前脚本运行时的PID加入hierarchy</span><br><span class="line">cat /sys/fs/cgroup/pids/parent/pids.current//结果为2</span><br></pre></td></tr></table></figure><p>注意，任何试图超过该限制的尝试都会失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /bin/echo &quot;Here&apos;s some processes for you.&quot; | cat</span><br><span class="line">-/bin/sh: can&apos;t fork</span><br></pre></td></tr></table></figure><p>即便我们移动到子进程的cgroup里（没有设置pids.max），也不会超过整个hierarychy的限制（这个例子里，是父进程的限制）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo $$ &gt; /sys/fs/cgroup/pids/parent/child/cgroup.procs</span><br><span class="line"># cat /sys/fs/cgroup/pids/parent/child/pids.current</span><br><span class="line">2</span><br><span class="line"># cat /sys/fs/cgroup/pids/parent/child/pids.max</span><br><span class="line">max</span><br><span class="line"># /bin/echo &quot;Here&apos;s some processes for you.&quot; | cat</span><br><span class="line">-&gt; -/bin/sh: can&apos;t fork</span><br></pre></td></tr></table></figure><p>此外，我们可以设置一个比pids.current小的限制值，这会阻止任何通过fork创建新进程的尝试（注意，shell本身也是pids.current里的一个）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /sys/fs/cgroup/pids/parent/pids.max</span><br><span class="line"># /bin/echo &quot;We can&apos;t even spawn a single process now.&quot;</span><br><span class="line">-&gt; -/bin/sh: can&apos;t fork</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/02/翻译-【cgroups】进程数目控制器（Process-Number-Controller）/linux.jpg&quot;&gt;

&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;cgroup hierarchy在进程数目达到上限以后会使用 进程数量控制器（process number controller）阻止继续fork或clone任何新的进程。触发进程数量限制时是否触发PID内存限制（memory cgroup）并不重要，因为PID是基础资源，因此，在cgroup hierarchy里必须要能通过限制cgourp里进程数目来阻止PID耗尽。&lt;/p&gt;
&lt;h1 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h1&gt;&lt;p&gt;设置最大进程数目到pids.max文件，就可以使用进程数量控制器（显然无法获取root cgroup的该文件）。当前cgroup中进程数量保存在pids.current文件里。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://seucr.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>翻译 |【cgroups】CPUSETS</title>
    <link href="https://seucr.github.io/2020/01/02/%E7%BF%BB%E8%AF%91-%E3%80%90cgroups%E3%80%91CPUSETS/"/>
    <id>https://seucr.github.io/2020/01/02/翻译-【cgroups】CPUSETS/</id>
    <published>2020-01-02T06:52:03.000Z</published>
    <updated>2020-03-27T07:05:35.855Z</updated>
    
    <content type="html"><![CDATA[<img src="/2020/01/02/翻译-【cgroups】CPUSETS/docker.jpg"><h1 id="1-Cpusets"><a href="#1-Cpusets" class="headerlink" title="1. Cpusets"></a>1. Cpusets</h1><h2 id="什么是cpusets？"><a href="#什么是cpusets？" class="headerlink" title="什么是cpusets？"></a>什么是cpusets？</h2><p>Cpusets提供了为一系列的进程指定一组CPU和内存节点（Memory Node）的机制，本文档中内存节点是指包含内存的在线节点。</p><p>Cpusets限制进程只能使用其当前cpuset中的CPU和Memory，它们在VFS中形成嵌套的层级结构，这对于大型系统动态任务分配来说是必要的。</p><a id="more"></a><p>进程通过sched_setaffinity()系统调用将CPU加入其CPU mask，或通过mbind()和set_mempolicy()系统调用将内存节点加入其内存策略的请求，都会被该进程的cpuset过滤，去除任何不在该cpuset中的CPU和内存节点。调度器不会将一个进程调度到其<strong>cpus_allowed</strong>向量不允许的CPU上，内核页分配器也不会在进程<strong>mems_allowed</strong>向量不允许的内存节点上分配内存。</p><p>用户层次的代码可以在cgroup虚拟文件系统中创建/删除cpuset，管理其属性和分配cpuset允许的CPU和内存节点，指定或查询进程所属的cpuset，以及罗列cpuset中所有进程pid。</p><h2 id="为什么需要cpuset？"><a href="#为什么需要cpuset？" class="headerlink" title="为什么需要cpuset？"></a>为什么需要cpuset？</h2><p>拥有很多处理器（CPU）、复杂内存缓存层级和诸多NUMA内存节点的大型计算机系统，对高效调度和进程内存管理提出了新的挑战。</p><p>通常小型系统只需要让操作系统在不同任务间自动共享CPU和内存资源，就可以达到足够的效能。但对于更大的系统，仔细的CPU和内存管理从而避免内存访问次数和竞争，显式地将任务安排到一组子系统上，会使得其效率更高。这对于如下系统更有价值：</p><ul><li>运行相同web应用多个实例的网络服务器</li><li>执行不同应用的服务器（例如，一个网络服务器和一个数据库）</li><li>运行高性能计算（HPC）应用的NUMA系统</li></ul><p>因为任务总在变化，这些子集，或“软分类”，必须要能动态调节，并且不影响其他正在执行的任务。正在执行的任务的内存页也要能随着内存位置调整而移动。</p><p>内核的cpuset补丁提供了实现这种自己的最低内核机制支持，它利用Linux内核中现有的CPU和内存分配代码来避免对关键调度器或内存分配器代码的任何额外影响。</p><h2 id="cpuset如何工作？"><a href="#cpuset如何工作？" class="headerlink" title="cpuset如何工作？"></a>cpuset如何工作？</h2><p>cpusets提供了一套内核机制，来限制（一组）进程使用的CPU和内存节点。</p><p>内核已经提供了机制来指定某个进程可能被调度的CPU（sched_setaffinity），以及指定进程获取内存的内存节点（mbind, set_mempolicy）。cpusets扩展了这两个机制：</p><ul><li>cpusets是允许的CPU和内存节点的集合，能被内核感知；</li><li>系统中任何进程都被绑定到一个cpuset，通过将task数据结构的指针指向一个cgroup数据结构来达成；</li><li>调用sched_setaffinity()时会使用当前任务允许的CPU进行过滤；</li><li>调用mbind和set_mempolicy时会使用当前任务允许的内存节点进行过滤；</li><li>对于任何cpuset，可以定义一个子cpuset，包含父cpuset中CPU和内存节点的子集；</li><li>cpuset的层级结构存放在/dev/cpuset里，供用户空间查看和操作；</li><li>cpuset可以标记为排他的（exclusive），这可以确保其他cpuset（直接祖先和后代除外）不能包含任何重叠的cpu或内存节点。</li><li>可以罗列加入到任何cpuset的所有进程pid</li></ul><p>cpuset的实现需要一点点简单的内核代码hook，都不在性能关键路径上：</p><p>（略）</p><p>需要先mount cgroup虚拟文件系统以浏览和修改cpuset。没有为cpuset新增任何系统调用，所有查询和修改都是通过cpuset的文件系统进行的。</p><p>每个进程的文件<strong>/proc/&lt;pid&gt;/status</strong>中会添加数行，显示进程的cpus_allowed和mems_allowed值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff</span><br><span class="line">Cpus_allowed_list:      0-127</span><br><span class="line">Mems_allowed:   ffffffff,ffffffff</span><br><span class="line">Mems_allowed_list:      0-63</span><br></pre></td></tr></table></figure><p>（注：这里的cpus_allowed和mems_allowed是进程“全局的”配置，是一个超集。后续cpusets设置的CPU和内存节点值，都必须在cpus_allowed和mems_allowed范围内配置。）</p><p>每个cpuset都在cgroup文件系统中包括如下文件：</p><ul><li>cpuset.cpus：cpuset里的CPU列表</li><li>cpuset.mems：cpuset里的内存节点列表</li><li>cpuset.memory_migrate：如置位，内存页会迁移到cpuset的内存节点</li><li>cpuset.cpu_exclusive：CPU是否被cpuset独占</li><li>cpuset.mem_exclusive：内存节点是否被cpuset独占</li><li>cpuset.mem_hardwall：是否只能使用cpuset指定的内存节点</li><li>cpuset.memory_pressure：只读，显示cpuset中进程产生的内存压力</li><li>cpuset.memory_spread_page：如置位，将页缓存均匀分配到允许的内存节点</li><li>cpuset.memory_spread_slab：如置位，将SLAB缓存均匀分配到允许的内存节点</li><li>cpuset.sched_load_balance：如置位，cpuset允许的CPU中进行负载均衡</li><li>cpuset.memory_pressure_enabled flag：是否计算内存压力（只有root cpuset有这个文件）</li></ul><p>可以通过mkdir()来创建新的cpusets，然后通过向上述合适的文件写值来修改该cpusets的属性，例如flag、允许的CPU和内存节点等。</p><p>嵌套cpusets的命名层次结构允许将大型系统划分为嵌套的、动态可更改的“软分区”。</p><p>通过将进程加入cpuset（子进程会在fork时自动继承该关联），可以将系统负载均衡的工作简化为将一组任务关联到某个限制CPU和内存节点使用的cpuset上。进程可以重新关联到另一个cpuset，只要cpuset的文件系统目录属性允许。</p><p>这种“大系统”的管理与使用sched_setaffinity、mbind和set_mempolicy系统调用对单个任务和内存区域所做的详细布局平滑地集成在一起。</p><p>每个cpuset都应遵循如下原则：</p><ul><li>它的CPU和内存节点必须是其父cpuset的子集；</li><li>除非其父cpuset是exclusive的，否则无法被置为exclusive；</li><li>如果它是CPU或内存节点exclusive的，他们无法与任何兄弟cpuset重叠。</li></ul><p>这些规则和cpuset的自然层次结构使独占保证的有效实施成为可能，而无需每次更改时扫描所有cpuset，以确保没有任何内容与独占cpuset重叠。另外，使用Linux虚拟文件系统（vfs）来表示cpuset层次结构为cpuset提供了熟悉的权限和名称空间，并且只需要最少的额外内核代码。</p><p>root cpuset（顶层）里cpus和mems文件是只读的，cpus文件通过CPU热插拔通知机制自动追踪了cpu_online_mask的值，mems文件通过cpuset_track_online_nodes回调则追踪了node_states[N_MEMORY]的值。</p><h2 id="什么是独占的（exclusive）cpuset？"><a href="#什么是独占的（exclusive）cpuset？" class="headerlink" title="什么是独占的（exclusive）cpuset？"></a>什么是独占的（exclusive）cpuset？</h2><h2 id="什么是内存压力（memory-pressure）？"><a href="#什么是内存压力（memory-pressure）？" class="headerlink" title="什么是内存压力（memory_pressure）？"></a>什么是内存压力（memory_pressure）？</h2><h2 id="什么是内存分散（memory-spread）？"><a href="#什么是内存分散（memory-spread）？" class="headerlink" title="什么是内存分散（memory spread）？"></a>什么是内存分散（memory spread）？</h2><h2 id="什么是负载均衡（sched-load-balance）？"><a href="#什么是负载均衡（sched-load-balance）？" class="headerlink" title="什么是负载均衡（sched_load_balance）？"></a>什么是负载均衡（sched_load_balance）？</h2><h2 id="什么是sched-relax-domain-level？"><a href="#什么是sched-relax-domain-level？" class="headerlink" title="什么是sched_relax_domain_level？"></a>什么是sched_relax_domain_level？</h2><p>（略）</p><h2 id="如何使用cpuset？"><a href="#如何使用cpuset？" class="headerlink" title="如何使用cpuset？"></a>如何使用cpuset？</h2><p>（可以直接看第二章范例…）</p><h1 id="使用范例和语法"><a href="#使用范例和语法" class="headerlink" title="使用范例和语法"></a>使用范例和语法</h1><p>创建、修改、使用cpuset都可以通过cpuset虚拟文件系统来达成。</p><p>mount文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mount -t tmpfs cgroups /sys/fs/cgroup</span><br><span class="line"># mkdir /sys/fs/cgroup/cpuset</span><br><span class="line"># mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset</span><br></pre></td></tr></table></figure><p>此时，就可以在/sys/fs/cgroup/cpuset可以查看系统cpuset的树形结构，例如/sys/fs/cgroup/cpuset表示整个系统的cpuset。</p><p>如果要创建新的cpuset hierarchy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cd /sys/fs/cgroup/cpuset</span><br><span class="line"># mkdir my_cpuset</span><br></pre></td></tr></table></figure><p>此时，在my_cpuset目录下就会找到如下文件了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ls</span><br><span class="line">cgroup.clone_children  cpuset.memory_pressure</span><br><span class="line">cgroup.event_control   cpuset.memory_spread_page</span><br><span class="line">cgroup.procs           cpuset.memory_spread_slab</span><br><span class="line">cpuset.cpu_exclusive   cpuset.mems</span><br><span class="line">cpuset.cpus            cpuset.sched_load_balance</span><br><span class="line">cpuset.mem_exclusive   cpuset.sched_relax_domain_level</span><br><span class="line">cpuset.mem_hardwall    notify_on_release</span><br><span class="line">cpuset.memory_migrate  tasks</span><br></pre></td></tr></table></figure><p>读取这些文件可以看到当前cpuset的信息：可以使用的CPU和内存节点，关联的进程…写这些文件则可以修改cpuset。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set some flags</span><br><span class="line"># /bin/echo 1 &gt; cpuset.cpu_exclusive</span><br><span class="line"></span><br><span class="line">Add some cpus:</span><br><span class="line"># /bin/echo 0-1 &gt; cpuset.cpus</span><br><span class="line"></span><br><span class="line">Add some mems:</span><br><span class="line"># /bin/echo 0 &gt; cpuset.mems</span><br><span class="line"></span><br><span class="line">Now attach your shell to this cpuset:</span><br><span class="line"># /bin/echo $$ &gt; tasks</span><br><span class="line"></span><br><span class="line">To remove all the CPUs:</span><br><span class="line"># /bin/echo &quot;&quot; &gt; cpuset.cpus        -&gt; clear cpus list</span><br></pre></td></tr></table></figure><p>（注：</p><ol><li><p>cpus和mems的值需要是当前系统正在运行的CPU和内存节点范围内的值，且要是root cpuset的子集； </p></li><li><p>attach进程时，需要先看一下进程的status文件，里面cpus_allowed和mems_allowed值 与 cpuset的cpus和mems值 是否有交集，如果没有，则无法添加进程。</p></li><li><p>写一个while(1){}的进程执行，通过设置cpuset.cpu_exclusive=1和cpuset.cpus值，可以指定该进程跑在不同的CPU上。</p><p>）</p></li></ol><p>还可以通过mkdir在你的cpuset里创建新的cpuset：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkdir my_sub_cs</span><br></pre></td></tr></table></figure><p>可以通过rmdir删除cpuset：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># rmdir my_sub_cs -rf</span><br></pre></td></tr></table></figure><p>注意，如果其中有其他cpuset，或有进程与其关联，会删除失败。</p><p>注：参考资料：</p><p><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/sec-cpuset" target="_blank" rel="noopener">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/sec-cpuset</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2020/01/02/翻译-【cgroups】CPUSETS/docker.jpg&quot;&gt;

&lt;h1 id=&quot;1-Cpusets&quot;&gt;&lt;a href=&quot;#1-Cpusets&quot; class=&quot;headerlink&quot; title=&quot;1. Cpusets&quot;&gt;&lt;/a&gt;1. Cpusets&lt;/h1&gt;&lt;h2 id=&quot;什么是cpusets？&quot;&gt;&lt;a href=&quot;#什么是cpusets？&quot; class=&quot;headerlink&quot; title=&quot;什么是cpusets？&quot;&gt;&lt;/a&gt;什么是cpusets？&lt;/h2&gt;&lt;p&gt;Cpusets提供了为一系列的进程指定一组CPU和内存节点（Memory Node）的机制，本文档中内存节点是指包含内存的在线节点。&lt;/p&gt;
&lt;p&gt;Cpusets限制进程只能使用其当前cpuset中的CPU和Memory，它们在VFS中形成嵌套的层级结构，这对于大型系统动态任务分配来说是必要的。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://seucr.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>读书 | 罗马人的故事X·条条大路通罗马</title>
    <link href="https://seucr.github.io/2019/09/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BD%97%E9%A9%AC%E4%BA%BA%E7%9A%84%E6%95%85%E4%BA%8BX%C2%B7%E6%9D%A1%E6%9D%A1%E5%A4%A7%E8%B7%AF%E9%80%9A%E7%BD%97%E9%A9%AC/"/>
    <id>https://seucr.github.io/2019/09/29/读书笔记-罗马人的故事X·条条大路通罗马/</id>
    <published>2019-09-29T07:46:17.000Z</published>
    <updated>2020-03-27T07:05:41.182Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/29/读书笔记-罗马人的故事X·条条大路通罗马/tabula.jpg" title="波伊廷格古地图"><h1 id="梗概"><a href="#梗概" class="headerlink" title="梗概"></a>梗概</h1><p>本册的时间线停留在安敦尼·庇护和马克·奥勒留之间，往前罗马帝国是亚欧非的主人，创造了辉煌的文明；再往后罗马帝国由盛而衰，步入诸神的黄昏。在这个时间点停下历史的脚步，忘记那些军事和政治的杀伐，讲一讲罗马人创造的宏伟道路，看一看罗马人的精神内在；可以说安排得十分恰当，毕竟再往后，就再也没有罗马人了。</p><p>本册着重讲述了罗马人的基础设施建设，从硬件建设和软件建设两个方面，介绍了罗马人在道路、上下水道、医疗、教育方面的辉煌成就，并由此突出了罗马人开放、高效、认真、灵活的民族性格。鉴于前册中也穿插介绍了各个时期的“地标式”建筑，例如图拉真记功柱等，以及同样是所谓“软件基础设施”的国家安全等内容，本册对这部分就一笔带过。</p><a id="more"></a><p>本册尽管很薄，但却是全套里引用图画最多的一册，甚至开篇有很多照片彩页，展现从罗马本土到欧洲、非洲、亚洲各地罗马时期的建筑遗迹。这些遗迹即便是放在21世纪的今天，其规模也是十分震撼的，看完照片，真的很想去实地亲手摸一摸这些伟大的历史。</p><h1 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h1><h2 id="罗马人-vs-中国人"><a href="#罗马人-vs-中国人" class="headerlink" title="罗马人 vs 中国人"></a>罗马人 vs 中国人</h2><p>本册开篇，作者就抛出了一个有意思的问题。在几乎相同的时间点（公元前三世纪），罗马人开始修筑后来遍布欧洲的道路网络，而东方的秦始皇开始修建的却是阻隔来往的后来号称万里的长城。</p><blockquote><p>修建长城的中国人和修筑了四通八达的道路网的罗马人的不同就在于，对于国家应该兴建什么样的大工程这件事认识不同。壁垒是断绝人的往来，而道路则是促进人的来往。那么，国家方位这一最重要的目的，是通过断绝与其他民族的来往来实现，还是通过促进本国内人民的来往来实现呢？</p><p>两个民族在这一方面观念的不同，对于中国和罗马这两大古代强国来说，甚至决定了以后的国家形态。</p></blockquote><p>从结论看来，这个问题就十分有趣。即便是在两千多年后的今天，中国和西方的选择（尽管西方世界变成了盎格鲁-萨克逊人主导），与当时并没有什么不同：西方人创造了互联网，而我们修建了强大的Great FireWall。</p><p>尽管作者抛出了合理的结论，但却没有给出问题合理的解释，即为什么会早在公元前三世纪，东西方就已经走向了两条不同的道路。作者似乎只是简单归结为民族性格不同，而要回答这个问题，可能就要写篇论文了。我也只能列出几个我想到的点。</p><ul><li><p>民族性格不同</p><p>罗马人在保留自己民族性格的同时，很早就大量继承了海洋民族希腊的思想（所以一般被称作希腊罗马时期）。</p><p>在海上防御是无法建造墙壁的，只能通过灵活机动的战术、数量优势、技术优势等方法取胜；希腊人喜欢移居海外，在地中海各处都有希腊城市，如何有更方便的交通方式应该是他们一直思考的问题。继承希腊人精神的罗马人，在面对北方蛮族的时候，应该首先想到的也是如何用更加灵活机动的战术击败对手，如何将军队、后勤物资更方便地送抵各处边境。为此，罗马人选择大规模建设标准化道路，将道路复线化、网络化，让军队、后勤有更多的选择。最终达到国道约8万公里、加上私营道路总共30万公里的规模。此外，道路也是罗马“文化输出”的一个形式，通过道路连接，将战败者的土地和罗马联系在一起，缓慢同化战败者，形成命运的共同体。这样，在面对新的敌人时，原本的战败者就会和罗马人站在一起（当然，罗马人对异族开放的态度也是关键）。</p><p>而秦朝起源于关中平原，地形狭长而居于秦岭和北山之间，所谓“雍州之地，崤函之固”。习惯于被群山拥抱的山地民族，似乎都更缺乏安全感，倾向于保守性格（即便是同为希腊人的斯巴达）。面对北部戎、狄等蛮族侵扰，秦朝选择在北面修筑长城，将自己圈起来免于蛮族袭击；即便秦灭六国坐拥九州，也无法摆脱“原生家庭”的影响，将秦长城扩建，一路向东，横跨整个北方。此后又历经汉、唐、宋、明多次修建、扩建，方为万里长城。</p><p>关于中国人各朝各代是否有系统的修建国内道路网的记录，未做探究。</p></li><li><p>生存环境不同</p><p>同一时期罗马人和中国人面对的对手不同，生存难易程度不同，罗马人面对的外部环境比中国人要好一些。</p><p>自从共和时期罗马人从罗马城市开始扩张，依靠罗马军团，击败伊特鲁里亚人、迦太基人、高卢人、日耳曼人等等，除了汉尼拔时期的第二次布匿战争有灭国风险外，其他时期并没有长时间地与对手进行拉锯或处于下风。这一点我认为从罗马军队数量可以得到验证，即便是第二次布匿战争时期，似乎最多时候也就只有十余个罗马军团，加上辅助兵也才十几万人；而在帝政时期，需要守卫长达两三千公里的莱茵-多瑙-两河防线，竟然也只有26个军团，而同时期的罗马城人口超过百万。这就是说，罗马人只需要用极少数的精锐兵力，配合行省辅助兵，就可以完成国防任务。</p><p>而同一时期的中国人（秦国人），尽管坐拥崤函之固，生存环境似乎更差。不仅需要提防东方六国的合纵，还要关注西北蛮族的动向，尽管没有研究过秦朝军力，但从商鞅变法所谓“军功制”就可以看出，秦朝需要将整个国家军事化，才能赢得生存之战。其后的汉朝面对北方的匈奴，更是有白登之围，后经文景两朝修生养息，汉武帝才将匈奴赶出漠南。</p><p>由此可见，中国面临的安全形势比罗马人要严峻得多，需要依赖一些额外的手段，才能防御自己。</p><p>另一个证明就是，哈德良在面对英伦北部蛮族的时候，也修建了哈德良长城；而后期罗马面对蛮族频繁的入侵，马可·奥勒留又重新修筑了罗马城墙。</p><p>所以，如果单纯将修墙归结于民族缺乏安全感的敏感性格，似乎有失偏颇。缺乏安全感并不完全源自自身，外部生存环境影响也很重要。</p></li></ul><h2 id="罗马人-vs-基督徒"><a href="#罗马人-vs-基督徒" class="headerlink" title="罗马人 vs 基督徒"></a>罗马人 vs 基督徒</h2><p>本册中，作者似乎一直在暗示一个观点，即罗马人是开放的而基督徒是保守的。我认为，和前面罗马人vs中国人一样，这只是不同时期的人在面对不同时期的环境时做出的选择不同，如若不是，为何基督教后来又在罗马皇帝戴克里先的主导下成为了罗马的国教呢？正统的罗马人为何没有延续下来呢？</p><p>除去评判是非外，有一些观点还是值得思考的。</p><h3 id="医疗和生死观"><a href="#医疗和生死观" class="headerlink" title="医疗和生死观"></a>医疗和生死观</h3><p>罗马人的生死观是豁达的：</p><blockquote><p>既然寿命已经，就该顺从天命。对于年轻、健壮的人负伤或者生病，要竭力治疗，而如果并没有遭遇不幸而寿命已尽，则从容升天乃是自然的生活态度。</p></blockquote><p>罗马人是火化的，骨灰埋葬的地方并不与世隔绝，甚至埋葬在国道旁边，配以有趣的墓志铭。</p><blockquote><p>风尘仆仆的旅行者可以坐在树荫下的墓地阶梯上，一边看着死者寄予生者的信息，一边休憩。在埋葬骨灰、还没有地狱概念的那个时代，生者和死者可以这样相邻共生。</p></blockquote><p>自从凯撒时期开始，罗马人就十分重视医生行业，给予来罗马行医的人以罗马公民权。同时大量建设浴场，每天下午的重要活动之一就是洗澡，可以想象，罗马人一定比中世纪乃至近代的欧洲人都要干净。在首都罗马，医疗甚至是公费的。</p><p>相比而言，基督教的生死观似乎更加保守。有了天堂和地狱之分，人间也就分了三六九等；死后不火化，坟墓只能建在远离城市的地方；尽管教堂的医疗也是免费，但作者认为这是为了和罗马医院和神庙抢生意。</p><h3 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h3><p>同样自凯撒时期，罗马给予在罗马的教师以罗马公民权，教师地位得到了进一步的提升。与道路建设不同，教育行业是私营而非国有（私塾开在了叫做“艾萨多拉“（街角）的地方）。这样，教师薪资可以随市场决定，教授内容也因人而异，允许不同的思想传播，</p><p>而当基督教成为国教，特别是后来宣布其他宗教为异端，人类的思想反而被禁锢，迎来了被成为黑暗时代的中世纪。人类在黑暗之中逡巡不前，科学的发现、新兴的思想，往往带来的是残酷的刑罚。</p><blockquote><p>那些认为社会应该用一种思想来统一的人掌握权力的时候，想要实行的便是按照自己的思想重新组织教育和福利。基督教成为罗马帝国的国教以后，基督教会所做的就是这件事。半个世纪以后，罗马帝国灭亡了。留下来的是可以成为基督教帝国的拜占庭帝国。位于罗马帝国东方的雅典学院和亚历山大的博学园，不久也停办了。这是因为，怀疑是研究的根本。</p></blockquote><p>中世纪，大量希腊罗马时期的珍贵文献被焚毁，建筑被破坏，但讽刺的是，基督教时期的道路甚至罗马教廷的用水，还是依赖罗马时期所建。</p><blockquote><p>罗马教廷尽管觉得水不可或缺，却不愿意以罗马皇帝的名字给水道命名。因此，图拉真水道取圣保罗的名字改名为”保罗水道“。这条水道至今仍在台伯河西岸一带供水。</p></blockquote><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><h2 id="共和精神"><a href="#共和精神" class="headerlink" title="共和精神"></a>共和精神</h2><p>在刚刚步入帝制的这最初的一百年里，其实仍有着浓重的“共和”气息，皇帝们还没有东方专制君主的味道。而正是这种共和的精神，构建了罗马的大厦，让罗马人能清醒地区分公与私，第一阶层能热情地投身公共事业、避免社会阶层收入差距过大，最终使得社会稳步前进。</p><p>在修建道路、水路上，罗马人丝毫没有想收回成本，既没有过桥过路费，水费也只有专门铺设通往私宅的水路时才象征性收取，罗马人只是将这些看做统治者必须要做的事情而已。这也是最朴素的共和（publica）理念吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/09/29/读书笔记-罗马人的故事X·条条大路通罗马/tabula.jpg&quot; title=&quot;波伊廷格古地图&quot;&gt;

&lt;h1 id=&quot;梗概&quot;&gt;&lt;a href=&quot;#梗概&quot; class=&quot;headerlink&quot; title=&quot;梗概&quot;&gt;&lt;/a&gt;梗概&lt;/h1&gt;&lt;p&gt;本册的时间线停留在安敦尼·庇护和马克·奥勒留之间，往前罗马帝国是亚欧非的主人，创造了辉煌的文明；再往后罗马帝国由盛而衰，步入诸神的黄昏。在这个时间点停下历史的脚步，忘记那些军事和政治的杀伐，讲一讲罗马人创造的宏伟道路，看一看罗马人的精神内在；可以说安排得十分恰当，毕竟再往后，就再也没有罗马人了。&lt;/p&gt;
&lt;p&gt;本册着重讲述了罗马人的基础设施建设，从硬件建设和软件建设两个方面，介绍了罗马人在道路、上下水道、医疗、教育方面的辉煌成就，并由此突出了罗马人开放、高效、认真、灵活的民族性格。鉴于前册中也穿插介绍了各个时期的“地标式”建筑，例如图拉真记功柱等，以及同样是所谓“软件基础设施”的国家安全等内容，本册对这部分就一笔带过。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="历史" scheme="https://seucr.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>HEXO之路</title>
    <link href="https://seucr.github.io/2019/09/27/HEXO%E4%B9%8B%E8%B7%AF/"/>
    <id>https://seucr.github.io/2019/09/27/HEXO之路/</id>
    <published>2019-09-27T06:32:39.000Z</published>
    <updated>2020-03-27T07:05:30.450Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/09/27/HEXO之路/hexo_cover.png"><p>最近查找资料时，看到很多漂亮的博客，拉到最下面都有一行小字：</p><blockquote><p><letf>powered by HEXO</letf></p></blockquote><p>恰好有闲暇不务正业，于是就有了这个站点的诞生。本文记录了站点的搭建过程，算是它出生过程的全记录吧。</p><a id="more"></a><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>HEXO是一个部署在npm上的package，提供了基于Markdown进行blog站点开发的框架。</p><p>没有搞过前端开发的人（e.g：我）看了这句话简直是黑人问号脸。慢慢来说：</p><ul><li><strong>网站开发</strong></li></ul><p>目前的网页一般都是HTML/JS/CSS的文件集合，浏览器依据这些文件渲染出可见的网页。</p><p>不过随着网页美观要求越来越高、人又越来越懒，直接写HTML/CSS做网页更费劲了，特别是各种tag的语法很不友好。例如，写一个简单的HTML标题需要这样写，tag还得匹配出现。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    This is a header</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><p>于是就有了Markdown的诞生。它对一个标题的写法简单多了：</p><blockquote><p># This is a header</p></blockquote><ul><li><strong>Markdown语言</strong></li></ul><p>如果把HTML叫做机器语言，那么Markdown语言就是介于人类语言和机器语言之间的存在。它不会取代HTML，只是为了让人们摆脱HTML语法的地域，更加方便高效地编写网页。</p><p>它的语法比HTML简单的多，而且兼容HTML的tag，还可以与HTML做语法转换。这个blog就是用Markdown语言写的。</p><ul><li><strong>nodejs &amp; npm</strong></li></ul><p>原文引用nodejs官网的描述：</p><blockquote><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p></blockquote><p>nodejs是一个JavaScript运行环境，而npm则是与nodejs一起运行的package manager。利用nodejs+npm，可以在本地运行第三方package，例如HEXO。</p><ul><li><strong>HEXO</strong></li></ul><p>HEXO是托管在npm网站的一个package，它提供了一个博客框架，可以利用Markdown语言编写博客并搭建站点；支持将博客站点部署在github上，从而能让所有人看到。</p><p>HEXO层次划分很清晰。支持各种插件，支持自定义主题，在其官网可以下到大量官方插件和主题。因为代码是全开源，所以任何人也都可以自行定制插件、主题。</p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>安装环境是<strong>Windows 7 SP1</strong> 。</p><h2 id="nodejs-amp-npm"><a href="#nodejs-amp-npm" class="headerlink" title="nodejs &amp; npm"></a>nodejs &amp; npm</h2><ol><li><p>下载<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs安装包</a>，并安装。现在nodejs里默认集成了npm，无需另行安装。</p></li><li><p><strong>重新打开</strong>cmd.exe，执行以下命令，成功的话就是nodejs和npm安装成功了：</p><blockquote><p>C:\User&gt; node -v</p><p>v10.16.3</p><p>C:\User&gt; npm -v</p><p>v6.9.0</p></blockquote></li><li><p>去<a href="https://www.npmjs.com" target="_blank" rel="noopener">npm官网</a>注册一个账号，需要记住用户名、密码、邮箱三者。</p></li><li><p>在cmd.exe里输入下面的命令，输入用户名、密码、邮箱登录npm：</p><blockquote><p>npm login</p></blockquote><p>通过下面的命令，如果看到自己的用户名，就是登录成功了：</p><blockquote><p>npm whoami</p></blockquote></li></ol><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>因为HEXO项目用git管理，所以需要安装git环境。</p><p>在<a href="https://gitforwindows.org/" target="_blank" rel="noopener">git官网</a>下载安装包，安装一下就好了。</p><h2 id="HEXO"><a href="#HEXO" class="headerlink" title="HEXO"></a>HEXO</h2><p><a href="https://hexo.io/" target="_blank" rel="noopener">HEXO官网</a>有很详细的指南，参照执行，似乎英文版更好理解一些，如果有困难，可以看<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">中文版</a>。这里只是引用原文，在cmd.exe里面依次执行：</p><blockquote><ul><li>npm install hexo-cli -g</li><li>hexo init blog</li><li>cd blog</li><li>npm install</li><li>hexo server</li></ul></blockquote><p>如果执行hexo server后有如下回显，其实就已经可以通过<a href="http://localhost:4000的URL，本地访问HEXO博客站点了。" target="_blank" rel="noopener">http://localhost:4000的URL，本地访问HEXO博客站点了。</a></p><blockquote><p>INFO  Start processing<br>INFO  Hexo is running at <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> . Press Ctrl+C to stop.</p></blockquote><h1 id="本地HEXO站点"><a href="#本地HEXO站点" class="headerlink" title="本地HEXO站点"></a>本地HEXO站点</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>HEXO的基本操作都可以参考<a href="https://hexo.io/docs/" target="_blank" rel="noopener">官网Doc</a>，建议看一遍各个页面的视频教程（油管视频，需代理），学起来就快多了。</p><p>例如，新建博客：</p><blockquote><p>hexo new post “$TITLE”</p></blockquote><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>HEXO默认使用的主题叫landscape，还算简约大方。</p><p>可以在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官网主题</a>里下载更多的主题，也可以自己做一个，如果够牛。</p><img src="/2019/09/27/HEXO之路/landscape_foresee.png"><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><p>前端的开发都站在基于他人的肩上来做的，而不要重复制作轮子。</p><p>官网插件里有很多插件可供选择，有不少有用的（比如允许用户评论、统计站点流量等），也有不少好玩的（比如爬douban的书影音、IMdB资料等）。</p><p>装上插件、配上心仪的主题之后，即便是本地站点，也变得很好玩。在后面我会把本站用到的插件罗列一二。</p><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><p>如果想让博客被更多人看到，就需要部署HEXO站点。</p><p>HEXO支持将站点托管的github上，这样所有人都可以通过github提供的域名访问到站点。如果土豪可以自己注册一个域名，那就有了一个十分个性化博客站了。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>github都是SSH加密通讯的，需要先装一个SSH环境，可以到<a href="https://www.mls-software.com/opensshd.html" target="_blank" rel="noopener">这个地址</a>下载安装。</p><p>安装后，<strong>重启</strong>cmd.exe，就可以用ssh命令了。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>还需要准备一个github仓库，这部分官网Doc写的比较绕，简而言之就是下面这几步。</p><ol><li><p>在github上创建一个repository，点右上角的“+”号就能看到“New Repository”。</p><p>注意，这个repository的name<strong>一定</strong>要是github的username，类型<strong>一定</strong>要是Public。</p></li><li><p>这样过一段时间之后，就可以在”My Repository”里看到自己的仓库，并访问仓库的域名了（$username.github.io）</p></li><li><p>上传本地SSH public key到github</p><p>在cmd.exe上执行:</p><blockquote><p>mkdir .ssh</p><p>cd .ssh</p><p>ssh-key gen -C $(github_mail_address)</p></blockquote><p>将.ssh/id_rsa.pub的内容贴到github的如下位置：右上角头像 - “ Setting “ - “ SSH and GPR keys”：</p><img src="/2019/09/27/HEXO之路/github_sshkey.png"></li><li><p>这时候，在cmd.exe上执行下面的命令，如果正确回显，那就OK了。</p><blockquote><p>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><p>Hi XXXX! You’ve successfully authenticated, but GitHub does not provide shell a<br>ccess.</p></blockquote></li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>这时候离部署github就差一步了：修改hexo工程的_config.yml。</p><p>有两个地方需要修改：</p><ol><li><p>URL：</p><p>将url改成github repo的URL，如果有子目录，填写在root栏位。</p><img src="/2019/09/27/HEXO之路/config_yml_url.png"></li><li><p>Deploy：</p><p>按如下格式填写，repo填写github repo的URL。</p><img src="/2019/09/27/HEXO之路/config_yml_deploy.png"></li></ol><p>修改后，在cmd.exe上执行下面三个命令，就可以完成部署：</p><blockquote><p>npm install hexo-deployer-git –save</p><p>hexo g</p><p>hexo d</p></blockquote><p>到这里，通过github repo的域名<a href="https://seucr.github.io/">https://seucr.github.io</a>访问站点了。</p><h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><p>个人最近觉得这两个工具开发比较顺溜。</p><ol><li><p>sublime text</p><p>可以打开整个目录，如果是python等解释型语言，自带解释器。</p><img src="/2019/09/27/HEXO之路/sublime.png"></li><li><p>Typora</p><p>连Marddown语言都不需要学了，直接用类似于Office Word的方式编辑，所见即所得。</p><img src="/2019/09/27/HEXO之路/typora.png"></li></ol><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h2><p>Algolia提供站内搜索服务，优点是免费，而且不需要绑定大陆信息；缺点是，NexT目前默认只能支持Algolia搜索Post标题和Page，内容无法搜索。</p><p>新版本的NexT主题已经集成了Algolia的支持，不过仍有一些小动作需要完成。大致的过程可以参考<a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">这里</a>，不过这个说明似乎比较旧，所以update如下：</p><ol><li><p>注册<a href="https://www.algolia.com" target="_blank" rel="noopener">Algolia</a>，创建Index。Index Name可以自由选择。</p></li><li><p>本地安装Algolia</p><blockquote><p>npm install –save hexo-algolia</p></blockquote></li><li><p>添加Key权限。在”API Keys” - “All API Keys” 里，编辑Usage API Key，添加Operation权限“AddObject”、”DeleteObject”、”listIndexes”、”deleteIndex”。</p></li><li><p>（下面开始就和教程不同了）在Windows cmd.exe下进入站点目录，执行：</p><blockquote><p>set HEXO_ALGOLIA_INDEXING_KEY=<strong>$(ADMIN API Key)</strong></p><p>hexo algolia</p></blockquote><p>如果成功，这时进入Algoria控制台 - “Indices” - “Browse”里，应该可以看到所有Post/Page信息，注意，是没有Post的正文信息的，所以无法搜索Post正文。</p></li><li><p>修改NexT<strong>站点配置文件</strong>，添加如下内容，其中信息都在Algoria控制台 - “API Keys”里能够找到：</p><blockquote><p>algolia:<br>  applicationID: ‘$(applicationID)’<br>  apiKey: ‘$(Search-Only_API_Key)’<br>  adminApiKey: ‘$(Admin_API_Key)’<br>  indexName: ‘$(Index_name)’<br>  chunkSize: 5000</p></blockquote></li><li><p>修改<strong>NexT主题</strong>配置文件，修改如下两处</p><blockquote><p>algolia_search:<br>  enable: <strong>true</strong></p><p>local_search:<br>  enable: <strong>true</strong></p></blockquote></li><li><p>此时重启站点，就可以看到侧边栏里的“搜索”字样了，点开后会弹出搜索框。</p></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://hexo.io/" target="_blank" rel="noopener">https://hexo.io</a></li><li><a href="https://www.cnblogs.com/trista222/p/8017300.html" target="_blank" rel="noopener">https://www.cnblogs.com/trista222/p/8017300.html</a></li><li><a href="https://www.jianshu.com/p/fa2354d61e37" target="_blank" rel="noopener">https://www.jianshu.com/p/fa2354d61e37</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2019/09/27/HEXO之路/hexo_cover.png&quot;&gt;

&lt;p&gt;最近查找资料时，看到很多漂亮的博客，拉到最下面都有一行小字：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;letf&gt;powered by HEXO&lt;/letf&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;恰好有闲暇不务正业，于是就有了这个站点的诞生。本文记录了站点的搭建过程，算是它出生过程的全记录吧。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="技术" scheme="https://seucr.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
